package vn.diemdanh.hethong.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Slf4j
@Component
public class JwtTokenProvider {

    @Value("${app.jwt.secret:your-default-secret-key-must-be-at-least-32-chars}")
    private String jwtSecret;

    @Value("${app.jwt.expiration:86400000}") // 24 hours by default
    private long jwtExpirationMs;

    private SecretKey key;

    @PostConstruct
    public void init() {
        this.key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
    }

    public String generateToken(Authentication authentication) {
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationMs);

        return Jwts.builder()
                .subject(userDetails.getUsername())
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(key)
                .compact();
    }

    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();

        return claims.getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().verifyWith(key).build().parseSignedClaims(token);
            return true;
        } catch (SecurityException ex) {
            log.error("Invalid JWT signature");
        } catch (MalformedJwtException ex) {
            log.error("Invalid JWT token");
        } catch (ExpiredJwtException ex) {
            log.error("Expired JWT token");
        } catch (UnsupportedJwtException ex) {
            log.error("Unsupported JWT token");
        } catch (IllegalArgumentException ex) {
            log.error("JWT claims string is empty");
        }
        return false;
    }

    // Tạo ra jwt từ thông tin user
    public String generateToken(CustomUserDetails userDetails) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationMs);

        try {
            String token = Jwts.builder()
                    .subject(Long.toString(userDetails.getId()))
                    .claim("userType", "USER")
                    .claim("userId", userDetails.getId())
                    .claim("email", userDetails.getUsername()) // Store email
                    .claim("role", userDetails.getRole())
                    .claim("username", userDetails.getUserRealUsername()) // Add real username
                    .issuedAt(now)
                    .expiration(expiryDate)
                    .signWith(key)
                    .compact();

            log.info("Generated JWT token for user ID: {}, email: {}, expires: {}",
                    userDetails.getId(), userDetails.getUsername(), expiryDate);
            return token;
        } catch (Exception e) {
            log.error("Error generating token for user: {}", userDetails.getId(), e);
            throw new RuntimeException("Error generating JWT token", e);
        }
    }

    // Tạo ra jwt từ thông tin admin
    public String generateTokenForAdmin(CustomAdminDetails adminDetails) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationMs);

        try {
            String token = Jwts.builder()
                    .subject(Integer.toString(adminDetails.getId()))
                    .claim("userType", "ADMIN")
                    .claim("adminId", adminDetails.getId())
                    .claim("email", adminDetails.getUsername()) // Store email
                    .claim("role", adminDetails.getRole())
                    .claim("username", adminDetails.getUserRealUsername()) // Add real username
                    .claim("fullName", adminDetails.getFullName()) // Add full name
                    .issuedAt(now)
                    .expiration(expiryDate)
                    .signWith(key)
                    .compact();

            log.info("Generated JWT token for admin ID: {}, email: {}, expires: {}",
                    adminDetails.getId(), adminDetails.getUsername(), expiryDate);
            return token;
        } catch (Exception e) {
            log.error("Error generating token for admin: {}", adminDetails.getId(), e);
            throw new RuntimeException("Error generating JWT token for admin", e);
        }
    }

    // Lấy thông tin user từ jwt
    public Long getUserIdFromJWT(String token) {
        try {
            Claims claims = parseToken(token);

            // Try to get from userId claim first, then fallback to subject
            Object userIdClaim = claims.get("userId");
            if (userIdClaim != null) {
                if (userIdClaim instanceof Number) {
                    return ((Number) userIdClaim).longValue();
                }
                return Long.parseLong(userIdClaim.toString());
            }

            return Long.parseLong(claims.getSubject());
        } catch (Exception e) {
            log.error("Error extracting user ID from JWT: {}", e.getMessage());
            throw new RuntimeException("Error extracting user ID from JWT", e);
        }
    }

    // Lấy thông tin admin từ jwt
    public Integer getAdminIdFromJWT(String token) {
        try {
            Claims claims = parseToken(token);

            // Try to get from adminId claim first, then fallback to subject
            Object adminIdClaim = claims.get("adminId");
            if (adminIdClaim != null) {
                if (adminIdClaim instanceof Number) {
                    return ((Number) adminIdClaim).intValue();
                }
                return Integer.parseInt(adminIdClaim.toString());
            }

            return Integer.parseInt(claims.getSubject());
        } catch (Exception e) {
            log.error("Error extracting admin ID from JWT: {}", e.getMessage());
            throw new RuntimeException("Error extracting admin ID from JWT", e);
        }
    }

    // Lấy loại user từ JWT
    public String getUserTypeFromJWT(String token) {
        try {
            Claims claims = parseToken(token);
            String userType = claims.get("userType", String.class);

            // If userType is not present, try to determine from other claims
            if (userType == null || userType.isEmpty()) {
                // Check if it has admin-specific claims
                if (claims.get("adminId") != null) {
                    log.debug("Determined user type as ADMIN from adminId claim");
                    return "ADMIN";
                } else if (claims.get("userId") != null) {
                    log.debug("Determined user type as USER from userId claim");
                    return "USER";
                } else {
                    // Fallback: assume USER if no specific type found
                    log.debug("No specific user type found, defaulting to USER");
                    return "USER";
                }
            }

            log.debug("User type from JWT: {}", userType);
            return userType;
        } catch (Exception e) {
            log.error("Error extracting user type from JWT: {}", e.getMessage());
            // Return default type instead of throwing exception
            return "USER";
        }
    }

    // Helper method to parse token safely
    private Claims parseToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    // Helper method to decode token without validation (for debugging)
    public Claims getClaimsFromToken(String token) {
        try {
            return parseToken(token);
        } catch (Exception e) {
            log.error("Error parsing token claims: {}", e.getMessage());
            return null;
        }
    }

    // Method to extract email from token
    public String getEmailFromJWT(String token) {
        try {
            Claims claims = parseToken(token);
            return claims.get("email", String.class);
        } catch (Exception e) {
            log.error("Error extracting email from JWT: {}", e.getMessage());
            return null;
        }
    }

    // Method to extract role from token
    public String getRoleFromJWT(String token) {
        try {
            Claims claims = parseToken(token);
            return claims.get("role", String.class);
        } catch (Exception e) {
            log.error("Error extracting role from JWT: {}", e.getMessage());
            return null;
        }
    }

    // Method to check if token will expire soon (within 1 hour)
    public boolean isTokenExpiringSoon(String token) {
        try {
            Claims claims = parseToken(token);
            Date expiration = claims.getExpiration();
            if (expiration == null) return false;

            long timeUntilExpiry = expiration.getTime() - System.currentTimeMillis();
            return timeUntilExpiry < 3600000; // 1 hour in milliseconds
        } catch (Exception e) {
            log.error("Error checking token expiration: {}", e.getMessage());
            return true; // Assume expiring if we can't parse
        }
    }
}